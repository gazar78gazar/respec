/**
 * SemanticIntegrationService - Integration Layer (REVISED for Sprint 2)
 *
 * Purpose: Bridge between Agent extraction and  semantic matching
 * - Receives: Already-extracted requirements from Agent (AnthropicService)
 * - Does: Routes to SemanticMatchingService for UC matching
 * - Returns: Matched results with form updates
 *
 * This provides:
 * - Fault domain isolation (Agent ‚Üê ‚Üí Matcher)
 * - Logging at integration boundaries
 * - Error handling without breaking agent
 * - Transformation between formats
 */

import {
  SemanticMatchingService,
  ExtractedNode,
  MatchResult,
} from "./SemanticMatchingService";
import { EnhancedFormUpdate, ChatResult } from "./RespecService";
import { ArtifactManager } from "./ArtifactManager";
import { ucDataLayer } from "./DataLayer";
import type { Maybe } from "../types/UCDataTypes";

// ============= INTEGRATION TYPES =============

export interface EnhancedChatResult extends ChatResult {
  matchResults?: MatchResult[];
  extractionSummary?: string;
  conflictsDetected?: any[];
  nextSuggestions?: string[];
}

export interface SemanticProcessingOptions {
  confidenceThreshold: number;
  includeDebugInfo: boolean;
}

// ============= MAIN INTEGRATION SERVICE =============

export class SemanticIntegrationService {
  private semanticMatchingService: SemanticMatchingService;
  private artifactManager: Maybe<ArtifactManager> = null;
  private processingOptions: SemanticProcessingOptions;

  constructor(
    semanticMatchingService: SemanticMatchingService,
    artifactManager?: ArtifactManager,
  ) {
    this.semanticMatchingService = semanticMatchingService;
    this.artifactManager = artifactManager || null;

    // Default processing options
    this.processingOptions = {
      confidenceThreshold: 0.7,
      includeDebugInfo: false,
    };
  }

  // ============= MAIN PROCESSING METHOD =============

  /**
   * Process already-extracted requirements from Agent
   * @param extractedRequirements - Requirements extracted by AnthropicService
   * @param conversationalResponse - Response generated by Agent
   * @returns EnhancedChatResult with UC matches and form updates
   */
  async processExtractedRequirements(
    extractedRequirements: any[],
    conversationalResponse: string,
  ): Promise<EnhancedChatResult> {
    try {
      console.log(
        "[SemanticIntegration] üì® Received",
        extractedRequirements.length,
        "extracted requirements",
      );

      // Convert agent extractions to ExtractedNode format
      const extractedNodes = this.convertToExtractedNodes(
        extractedRequirements,
      );

      if (extractedNodes.length === 0) {
        console.log("[SemanticIntegration] ‚ö†Ô∏è  No requirements to match");
        return {
          success: true,
          systemMessage: conversationalResponse,
          formUpdates: [],
          confidence: 1.0,
        };
      }

      // Match to UC
      console.log(
        "[SemanticIntegration] üîç Sending to SemanticMatchingService...",
      );
      const matchResults =
        await this.semanticMatchingService.matchExtractedNodesToUC(
          extractedNodes,
        );
      console.log(
        "[SemanticIntegration] ‚úÖ Received",
        matchResults.length,
        "UC matches",
      );

      // Log matches for debugging
      matchResults.forEach((match) => {
        console.log(`[SemanticIntegration] üìç Match:`, {
          text: match.extractedNode.text,
          uc: `${match.ucMatch.id} (${match.ucMatch.name})`,
          type: match.ucMatch.type,
          confidence: match.ucMatch.confidence,
        });
      });

      // Filter by confidence threshold
      const highConfidenceMatches = matchResults.filter(
        (m) =>
          m.ucMatch.confidence >= this.processingOptions.confidenceThreshold,
      );

      console.log(
        "[SemanticIntegration] üéØ",
        highConfidenceMatches.length,
        "matches above threshold",
      );

      // Route matches by node type (this adds specs to artifacts, including auto-fulfilled dependencies)
      await this.routeMatchesByType(highConfidenceMatches);

      // Generate form updates from respec artifact (includes auto-added dependencies)
      const formUpdates = this.generateFormUpdatesFromRespec();

      console.log(
        "[SemanticIntegration] üìù",
        formUpdates.length,
        "form updates generated (includes dependencies)",
      );

      // Build result
      const result: EnhancedChatResult = {
        success: true,
        systemMessage: conversationalResponse, // Use Agent's response
        formUpdates,
        confidence: this.calculateAverageConfidence(matchResults),
        matchResults: this.processingOptions.includeDebugInfo
          ? matchResults
          : undefined,
        extractionSummary: this.buildExtractionSummary(matchResults),
      };

      return result;
    } catch (error) {
      console.error("[SemanticIntegration] ‚ùå Processing failed:", error);
      throw error; // Fail fast for MVP
    }
  }

  // ============= CONVERSION METHODS =============

  private convertToExtractedNodes(requirements: any[]): ExtractedNode[] {
    console.error("convertToExtractedNodes - using section");
    return requirements.map((req) => ({
      text: `${req.field}: ${req.value}`,
      category: req.section,
      value: req.value,
      context: req.originalRequest || req.value,
    }));
  }

  /**
   * Generate form updates from respec artifact
   * This includes auto-added dependency specs that weren't in the original matches
   */
  private generateFormUpdatesFromRespec(): EnhancedFormUpdate[] {
    const formUpdates: EnhancedFormUpdate[] = [];

    if (!this.artifactManager) {
      console.warn(
        "[SemanticIntegration] No artifact manager - cannot generate form updates",
      );
      return formUpdates;
    }

    // Get the respec artifact which contains all approved specs (including dependencies)
    const respecArtifact = this.artifactManager.getRespecArtifact();

    Object.values(respecArtifact.specifications).forEach((spec) => {
      const fullSpec = ucDataLayer.getSpecification(spec.id);
      if (!fullSpec) {
        console.log(
          `[SemanticIntegration] ??  No full spec found for ${spec.id}`,
        );
        return;
      }

      const uiField = ucDataLayer.getUiFieldByFieldName(fullSpec.field_name);
      if (!uiField) {
        console.log(
          `[SemanticIntegration] ??  No ui field found for ${spec.id}`,
        );
        return;
      }

      console.log(
        `[SemanticIntegration] ?? Generating form update for ${spec.id} = ${spec.value}`,
        { uiField },
      );

      formUpdates.push({
        section: uiField.section,
        field: uiField.field_name,
        value: spec.value,
        confidence: spec.confidence || 1.0,
        isAssumption:
          spec.source === "dependency" ||
          (spec.source === "llm" && (spec.confidence || 1.0) < 0.9),
        originalRequest: spec.originalRequest,
        substitutionNote: spec.substitutionNote,
      });
    });

    return formUpdates;
  }

  /**
   * Select best matching option from dropdown values
   * Uses case-insensitive partial matching and semantic similarity
   */
  // private selectBestOption(
  //   extractedValue: any,
  //   extractedText: string,
  //   availableOptions: string[]
  // ): string {
  //   // If extracted value is already in options, use it
  //   if (availableOptions.includes(extractedValue)) {
  //     return extractedValue;
  //   }

  //   // Try case-insensitive exact match
  //   const lowerValue = String(extractedValue || '').toLowerCase();
  //   const exactMatch = availableOptions.find(opt => opt.toLowerCase() === lowerValue);
  //   if (exactMatch) return exactMatch;

  //   // Try partial match (e.g., "fanless" matches "Fanless Operation")
  //   const partialMatch = availableOptions.find(opt =>
  //     opt.toLowerCase().includes(lowerValue) ||
  //     lowerValue.includes(opt.toLowerCase())
  //   );
  //   if (partialMatch) return partialMatch;

  //   // Try semantic matching on extracted text (e.g., "compact" ‚Üí "Compact")
  //   const textLower = extractedText.toLowerCase();
  //   const semanticMatch = availableOptions.find(opt => {
  //     const optLower = opt.toLowerCase();
  //     return textLower.includes(optLower) || optLower.includes(textLower);
  //   });
  //   if (semanticMatch) return semanticMatch;

  //   // Fallback to first option (with warning)
  //   console.warn(`[SemanticIntegration] ‚ö†Ô∏è  Could not match "${extractedValue}" to options:`, availableOptions);
  //   return availableOptions[0];
  // }

  // ============= ROUTING BY NODE TYPE (Sprint 2 Week 2: Artifact Management) =============

  private async routeMatchesByType(matches: MatchResult[]): Promise<void> {
    for (const match of matches) {
      const { ucMatch, value } = match;

      switch (ucMatch.type) {
        case "specification":
          await this.handleSpecificationMatch(ucMatch.id, value, match);
          break;

        case "requirement":
          await this.handleRequirementMatch(ucMatch.id);
          break;

        default:
          console.warn(`[Route] ‚ùì Unknown node type: ${ucMatch.type}`);
      }
    }
  }

  // ============= SPECIFICATION HANDLING =============

  private async handleSpecificationMatch(
    specId: string,
    value: any,
    match: MatchResult,
  ): Promise<void> {
    console.log(`[Route] üéØ SPECIFICATION: ${specId} = ${value}`);

    // If artifact manager available, use full Week 2 flow
    if (this.artifactManager) {
      try {
        // SPRINT 3 FIX: Get specification from UCDataLayer (P## IDs) instead of UCEngine (spc### IDs)
        const uc8Spec = ucDataLayer.getSpecification(specId);
        if (!uc8Spec) {
          console.warn(
            `[Route] ‚ö†Ô∏è  Specification ${specId} not found in UC8 dataset`,
          );
          return;
        }

        console.log(`[Route] ‚úÖ Found UC8 spec: ${uc8Spec.name} (${specId})`);

        // Step 2: Add to mapped artifact
        await this.artifactManager.addSpecificationToMapped(
          uc8Spec,
          value,
          match.extractedNode.context || "",
          match.ucMatch.rationale || "",
          "llm",
        );

        // Step 3: Trigger conflict detection
        const conflictResult = await this.artifactManager.detectConflicts();

        // Step 4: Sprint 3 - NO auto-resolution, ALL conflicts go to agent for binary question
        if (conflictResult.hasConflict) {
          console.log(
            `[Route] üö® ${conflictResult.conflicts.length} conflict(s) detected - BLOCKING for user resolution`,
          );
          console.log(
            `[Route] Conflict types: ${conflictResult.conflicts
              .map((c) => c.type)
              .join(", ")}`,
          );
          // Do NOT move to respec - specs stay in mapped until user resolves via agent
          // Agent will receive conflict data via getActiveConflictsForAgent() in app.tsx
        } else {
          console.log(
            `[Route] ‚úÖ No conflicts - moving non-conflicting specs to respec`,
          );
          await this.artifactManager.moveNonConflictingToRespec();
        }
      } catch (error) {
        console.error(
          `[Route] ‚ùå Error handling specification ${specId}:`,
          error,
        );
        // Fall through to legacy behavior
      }
    } else {
      // Legacy path: no artifact manager (shouldn't happen in Sprint 2 Week 2)
      console.log(`[Route] ‚ö†Ô∏è  No artifact manager - using legacy path`);
    }
  }

  // ============= REQUIREMENT HANDLING =============

  private async handleRequirementMatch(reqId: string): Promise<void> {
    console.log(`[Route] üìã REQUIREMENT: ${reqId}`);

    if (this.artifactManager) {
      try {
        // Get all child specifications for this requirement
        const childSpecs = ucDataLayer.getSpecificationsByRequirement(reqId);

        if (childSpecs.length === 0) {
          console.warn(
            `[Route] ‚ö†Ô∏è  No specifications found for requirement ${reqId}`,
          );
          return;
        }

        console.log(
          `[Route] üìã Found ${childSpecs.length} specifications for requirement ${reqId}`,
        );

        // Add all child specifications to mapped artifact
        // Sprint 3 Week 1: Check for existing user-selected values before adding
        for (const spec of childSpecs) {
          // Check if spec already exists with user-selected value
          const existingInMapped =
            this.artifactManager.findSpecificationInArtifact("mapped", spec.id);
          const existingInRespec =
            this.artifactManager.findSpecificationInArtifact("respec", spec.id);

          if (existingInMapped) {
            // Check source - preserve user selections
            if (
              existingInMapped.source === "user" ||
              existingInMapped.source === "direct_extraction"
            ) {
              console.log(
                `[Route] ‚ö†Ô∏è  Skipping ${spec.id} - user-selected value already exists in mapped ` +
                  `(value: "${existingInMapped.value}")`,
              );
              continue; // Don't overwrite user selection
            } else {
              console.log(
                `[Route] Spec ${spec.id} exists in mapped with system value, will be updated`,
              );
            }
          }

          if (existingInRespec) {
            // Spec already in respec - cross-artifact conflict will be detected
            console.log(
              `[Route] ‚ö†Ô∏è  Spec ${spec.id} exists in respec - cross-artifact conflict will be detected`,
            );
            // Continue adding to mapped, conflict detection will handle it
          }

          await this.artifactManager.addSpecificationToMapped(
            spec,
            null,
            `From requirement ${reqId}`,
            `Auto-added as part of requirement ${reqId}`,
            "llm",
          );
        }

        // Trigger conflict detection
        const conflictResult = await this.artifactManager.detectConflicts();

        if (!conflictResult.hasConflict) {
          console.log(
            `[Route] ‚úÖ No conflicts - moving requirement + ${childSpecs.length} children to respec`,
          );
          await this.artifactManager.moveNonConflictingToRespec();
        } else {
          console.log(
            `[Route] ‚ö†Ô∏è  Conflicts detected - holding requirement in mapped`,
          );
        }
      } catch (error) {
        console.error(`[Route] ‚ùå Error handling requirement ${reqId}:`, error);
      }
    }
  }

  // ============= UTILITY METHODS =============

  private buildExtractionSummary(matches: MatchResult[]): string {
    if (matches.length === 0) {
      return "No UC matches found";
    }

    const byType = {
      specification: matches.filter((m) => m.ucMatch.type === "specification")
        .length,
      requirement: matches.filter((m) => m.ucMatch.type === "requirement")
        .length,
      // domain: matches.filter(m => m.ucMatch.type === 'domain').length
    };

    return `Matched ${matches.length} nodes: ${byType.specification} specs, ${byType.requirement} reqs, ${byType.domain} domains`;
  }

  private calculateAverageConfidence(matches: MatchResult[]): number {
    if (matches.length === 0) return 0.5;

    const sum = matches.reduce((acc, m) => acc + m.ucMatch.confidence, 0);
    return sum / matches.length;
  }
}

// ============= FACTORY FUNCTION =============

export function createSemanticIntegrationService(
  semanticMatchingService: SemanticMatchingService,
  artifactManager?: ArtifactManager,
): SemanticIntegrationService {
  return new SemanticIntegrationService(
    semanticMatchingService,
    artifactManager,
  );
}
