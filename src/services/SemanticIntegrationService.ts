/**
 * SemanticIntegrationService - Integration Layer (REVISED for Sprint 2)
 *
 * Purpose: Bridge between Agent extraction and  semantic matching
 * - Receives: Already-extracted specifications from Agent (AnthropicService)
 * - Does: Routes to SemanticMatchingService for UC specification matching
 * - Returns: Matched results with form updates
 *
 * This provides:
 * - Fault domain isolation (Agent ‚Üê ‚Üí Matcher)
 * - Logging at integration boundaries
 * - Error handling without breaking agent
 * - Transformation between formats
 */

import { SemanticMatchingService } from "./SemanticMatchingService";
import type {
  EnhancedChatResult,
  ExtractedNode,
  MatchResult,
  SemanticProcessingOptions,
} from "../types/semantic.types";
import { ArtifactManager } from "./ArtifactManager";
import { ucDataLayer } from "./DataLayer";
import type { Maybe } from "../types/service.types";

// ============= INTEGRATION TYPES =============
// Types moved to ../types/semantic.types.ts

// ============= MAIN INTEGRATION SERVICE =============

export class SemanticIntegrationService {
  private semanticMatchingService: SemanticMatchingService;
  private artifactManager: Maybe<ArtifactManager> = null;
  private processingOptions: SemanticProcessingOptions;

  constructor(
    semanticMatchingService: SemanticMatchingService,
    artifactManager?: ArtifactManager,
  ) {
    this.semanticMatchingService = semanticMatchingService;
    this.artifactManager = artifactManager || null;

    // Default processing options
    this.processingOptions = {
      confidenceThreshold: 0.7,
      includeDebugInfo: false,
    };
  }

  // ============= MAIN PROCESSING METHOD =============

  /**
   * Process already-extracted specifications from Agent
   * @param extractedRequirements - Specifications extracted by AnthropicService
   * @param conversationalResponse - Response generated by Agent
   * @returns EnhancedChatResult with UC matches and form updates
   */
  async processExtractedRequirements(
    extractedRequirements: unknown[],
    conversationalResponse: string,
  ): Promise<EnhancedChatResult> {
    try {
      console.log(
        "[SemanticIntegration] üì® Received",
        extractedRequirements.length,
        "extracted requirements",
      );

      // Convert agent extractions to ExtractedNode format
      const extractedNodes = this.convertToExtractedNodes(
        extractedRequirements,
      );

      if (extractedNodes.length === 0) {
        console.log("[SemanticIntegration] ‚ö†Ô∏è  No specifications to match");
        return {
          success: true,
          systemMessage: conversationalResponse,
          formUpdates: [],
          confidence: 1.0,
        };
      }

      // Match to UC
      console.log(
        "[SemanticIntegration] üîç Sending to SemanticMatchingService...",
      );
      const matchResults =
        await this.semanticMatchingService.matchExtractedNodesToUC(
          extractedNodes,
        );
      console.log(
        "[SemanticIntegration] ‚úÖ Received",
        matchResults.length,
        "UC matches",
      );

      // Log matches for debugging
      matchResults.forEach((match) => {
        console.log(`[SemanticIntegration] üìç Match:`, {
          text: match.extractedNode.text,
          uc: `${match.ucMatch.id} (${match.ucMatch.name})`,
          type: match.ucMatch.type,
          confidence: match.ucMatch.confidence,
        });
      });

      // Filter by confidence threshold
      const highConfidenceMatches = matchResults.filter(
        (m) =>
          m.ucMatch.confidence >= this.processingOptions.confidenceThreshold,
      );

      console.log(
        "[SemanticIntegration] üéØ",
        highConfidenceMatches.length,
        "matches above threshold",
      );

      // Route matches (specifications only) into artifacts, including auto-fulfilled dependencies.
      await this.routeMatchesByType(highConfidenceMatches);

      // Generate form updates from respec artifact (includes auto-added dependencies)
      const formUpdates =
        this.artifactManager?.generateFormUpdatesFromRespec() || [];

      console.log(
        "[SemanticIntegration] üìù",
        formUpdates.length,
        "form updates generated (includes dependencies)",
      );

      // Build result
      const result: EnhancedChatResult = {
        success: true,
        systemMessage: conversationalResponse, // Use Agent's response
        formUpdates,
        confidence: this.calculateAverageConfidence(matchResults),
        matchResults: this.processingOptions.includeDebugInfo
          ? matchResults
          : undefined,
        extractionSummary: this.buildExtractionSummary(matchResults),
      };

      return result;
    } catch (error) {
      console.error("[SemanticIntegration] ‚ùå Processing failed:", error);
      throw error; // Fail fast for MVP
    }
  }

  // ============= CONVERSION METHODS =============

  private convertToExtractedNodes(requirements: unknown[]): ExtractedNode[] {
    console.error("convertToExtractedNodes - using section");
    return requirements.map((req) => {
      const requirement = req as {
        field: string;
        value: unknown;
        section: string;
        originalRequest?: string;
      };
      return {
        text: `${requirement.field}: ${requirement.value}`,
        category: requirement.section,
        value: requirement.value,
        context: requirement.originalRequest
          ? String(requirement.originalRequest)
          : requirement.value !== undefined
            ? String(requirement.value)
            : "",
      };
    });
  }

  /**
   * Select best matching option from dropdown values
   * Uses case-insensitive partial matching and semantic similarity
   */
  // private selectBestOption(
  //   extractedValue: any,
  //   extractedText: string,
  //   availableOptions: string[]
  // ): string {
  //   // If extracted value is already in options, use it
  //   if (availableOptions.includes(extractedValue)) {
  //     return extractedValue;
  //   }

  //   // Try case-insensitive exact match
  //   const lowerValue = String(extractedValue || '').toLowerCase();
  //   const exactMatch = availableOptions.find(opt => opt.toLowerCase() === lowerValue);
  //   if (exactMatch) return exactMatch;

  //   // Try partial match (e.g., "fanless" matches "Fanless Operation")
  //   const partialMatch = availableOptions.find(opt =>
  //     opt.toLowerCase().includes(lowerValue) ||
  //     lowerValue.includes(opt.toLowerCase())
  //   );
  //   if (partialMatch) return partialMatch;

  //   // Try semantic matching on extracted text (e.g., "compact" ‚Üí "Compact")
  //   const textLower = extractedText.toLowerCase();
  //   const semanticMatch = availableOptions.find(opt => {
  //     const optLower = opt.toLowerCase();
  //     return textLower.includes(optLower) || optLower.includes(textLower);
  //   });
  //   if (semanticMatch) return semanticMatch;

  //   // Fallback to first option (with warning)
  //   console.warn(`[SemanticIntegration] ‚ö†Ô∏è  Could not match "${extractedValue}" to options:`, availableOptions);
  //   return availableOptions[0];
  // }

  // ============= ROUTING BY NODE TYPE (Sprint 2 Week 2: Artifact Management) =============

  private async routeMatchesByType(matches: MatchResult[]): Promise<void> {
    for (const match of matches) {
      const { ucMatch, value } = match;
      if (ucMatch.type !== "specification") {
        console.warn(
          `[Route] ? Ignoring unsupported node type: ${ucMatch.type}`,
        );
        continue;
      }

      await this.handleSpecificationMatch(ucMatch.id, value, match);
    }
  }

  // ============= SPECIFICATION HANDLING =============

  private async handleSpecificationMatch(
    specId: string,
    value: unknown,
    match: MatchResult,
  ): Promise<void> {
    console.log(`[Route] üéØ SPECIFICATION: ${specId} = ${value}`);

    // If artifact manager available, use full Week 2 flow
    if (this.artifactManager) {
      try {
        // SPRINT 3 FIX: Get specification from UCDataLayer (P## IDs) instead of UCEngine (spc### IDs)
        const uc8Spec = ucDataLayer.getSpecification(specId);
        if (!uc8Spec) {
          console.warn(
            `[Route] ‚ö†Ô∏è  Specification ${specId} not found in UC8 dataset`,
          );
          return;
        }

        console.log(`[Route] ‚úÖ Found UC8 spec: ${uc8Spec.name} (${specId})`);

        // Step 2: Add to mapped artifact
        await this.artifactManager.addSpecificationToMapped(
          uc8Spec,
          value,
          match.extractedNode.context || "",
          match.ucMatch.rationale || "",
          "llm",
        );

        // Step 3: Trigger conflict detection
        const conflictResult =
          await this.artifactManager.detectExclusionConflicts();

        // Step 4: Sprint 3 - NO auto-resolution, ALL conflicts go to agent for binary question
        if (conflictResult.hasConflict) {
          console.log(
            `[Route] üö® ${conflictResult.conflicts.length} conflict(s) detected - BLOCKING for user resolution`,
          );
          console.log(
            `[Route] Conflict types: ${conflictResult.conflicts
              .map((c) => c.type)
              .join(", ")}`,
          );
          // Do NOT move to respec - specs stay in mapped until user resolves via agent
          // Agent will receive conflict data via getActiveConflictsForAgent() in app.tsx
        } else {
          console.log(
            `[Route] ‚úÖ No conflicts - moving non-conflicting specs to respec`,
          );
          await this.artifactManager.moveNonConflictingToRespec();
        }
      } catch (error) {
        console.error(
          `[Route] ‚ùå Error handling specification ${specId}:`,
          error,
        );
        // Fall through to legacy behavior
      }
    } else {
      // Legacy path: no artifact manager (shouldn't happen in Sprint 2 Week 2)
      console.log(`[Route] ‚ö†Ô∏è  No artifact manager - using legacy path`);
    }
  }

  // ============= UTILITY METHODS =============

  private buildExtractionSummary(matches: MatchResult[]): string {
    if (matches.length === 0) {
      return "No UC matches found";
    }

    const specCount = matches.filter(
      (m) => m.ucMatch.type === "specification",
    ).length;

    return `Matched ${matches.length} nodes: ${specCount} specs`;
  }

  private calculateAverageConfidence(matches: MatchResult[]): number {
    if (matches.length === 0) return 0.5;

    const sum = matches.reduce((acc, m) => acc + m.ucMatch.confidence, 0);
    return sum / matches.length;
  }
}

// ============= FACTORY FUNCTION =============

export function createSemanticIntegrationService(
  semanticMatchingService: SemanticMatchingService,
  artifactManager?: ArtifactManager,
): SemanticIntegrationService {
  return new SemanticIntegrationService(
    semanticMatchingService,
    artifactManager,
  );
}
