/**
 * SemanticIntegrationService - Integration Layer
 *
 * Purpose: Bridge between Agent extraction and  semantic matching
 * - Receives: Already-extracted specifications from Agent (PreSaleEngineer)
 * - Does: Routes to SemanticExtractor for UC specification matching
 * - Returns: Matched results with form updates
 *
 * This provides:
 * - Fault domain isolation (Agent <-> Matcher)
 * - Logging at integration boundaries
 * - Error handling without breaking agent
 * - Transformation between formats
 */

import { SemanticExtractor } from "./agents/SemanticExtractor";
import type {
  EnhancedChatResult,
  ExtractedNode,
  MatchResult,
  SemanticProcessingOptions,
} from "../types/semantic.types";
import { ArtifactManager } from "./ArtifactManager";
import { ucDataLayer } from "./DataLayer";
import type { Maybe } from "../types/service.types";

// ============= MAIN INTEGRATION SERVICE =============

export class SemanticIntegrationService {
  private semanticExtractor: SemanticExtractor;
  private artifactManager: Maybe<ArtifactManager> = null;
  private processingOptions: SemanticProcessingOptions;

  constructor(
    semanticExtractor: SemanticExtractor,
    artifactManager?: ArtifactManager,
  ) {
    this.semanticExtractor = semanticExtractor;
    this.artifactManager = artifactManager || null;

    // Default processing options
    this.processingOptions = {
      confidenceThreshold: 0.7,
      includeDebugInfo: false,
    };
  }

  // ============= MAIN PROCESSING METHOD =============

  /**
   * Process already-extracted specifications from Agent
   * @param extractedRequirements - Specifications extracted by PreSaleEngineer
   * @param conversationalResponse - Response generated by Agent
   * @returns EnhancedChatResult with UC matches and form updates
   */
  async processExtractedRequirements(
    extractedRequirements: unknown[],
    conversationalResponse: string,
  ): Promise<EnhancedChatResult> {
    try {
      console.log(
        "[SemanticIntegration] ðŸ“¨ Received",
        extractedRequirements.length,
        "extracted requirements",
      );

      // Convert agent extractions to ExtractedNode format
      const extractedNodes = this.convertToExtractedNodes(
        extractedRequirements,
      );

      if (extractedNodes.length === 0) {
        console.log("[SemanticIntegration] âš ï¸  No specifications to match");
        return {
          success: true,
          systemMessage: conversationalResponse,
          formUpdates: [],
          confidence: 1.0,
        };
      }

      // Match to UC
      console.log("[SemanticIntegration] ðŸ” Sending to SemanticExtractor...");
      const matchResults =
        await this.semanticExtractor.matchExtractedNodesToUC(extractedNodes);
      console.log(
        "[SemanticIntegration] âœ… Received",
        matchResults.length,
        "UC matches",
      );

      // Log matches for debugging
      matchResults.forEach((match) => {
        console.log(`[SemanticIntegration] ðŸ“ Match:`, {
          text: match.extractedNode.text,
          uc: `${match.ucMatch.id} (${match.ucMatch.name})`,
          type: match.ucMatch.type,
          confidence: match.ucMatch.confidence,
        });
      });

      // Filter by confidence threshold
      const highConfidenceMatches = matchResults.filter(
        (m) =>
          m.ucMatch.confidence >= this.processingOptions.confidenceThreshold,
      );

      console.log(
        "[SemanticIntegration] ðŸŽ¯",
        highConfidenceMatches.length,
        "matches above threshold",
      );

      // Route matches (specifications only) into artifacts, including auto-fulfilled dependencies.
      await this.routeMatchesByType(highConfidenceMatches);

      // Generate form updates from respec artifact (includes auto-added dependencies)
      const formUpdates =
        this.artifactManager?.generateFormUpdatesFromRespec() || [];

      console.log(
        "[SemanticIntegration] ðŸ“",
        formUpdates.length,
        "form updates generated (includes dependencies)",
      );

      // Build result
      const result: EnhancedChatResult = {
        success: true,
        systemMessage: conversationalResponse, // Use Agent's response
        formUpdates,
        confidence: this.calculateAverageConfidence(matchResults),
        matchResults: this.processingOptions.includeDebugInfo
          ? matchResults
          : undefined,
        extractionSummary: this.buildExtractionSummary(matchResults),
      };

      return result;
    } catch (error) {
      console.error("[SemanticIntegration] âŒ Processing failed:", error);
      throw error; // Fail fast for MVP
    }
  }

  // ============= CONVERSION METHODS =============

  private convertToExtractedNodes(requirements: unknown[]): ExtractedNode[] {
    console.log("[SemanticIntegration] convertToExtractedNodes using section");
    return requirements.map((req) => {
      const requirement = req as {
        field: string;
        value: unknown;
        section: string;
        originalRequest?: string;
      };
      return {
        text: `${requirement.field}: ${requirement.value}`,
        category: requirement.section,
        value: requirement.value,
        context: requirement.originalRequest
          ? String(requirement.originalRequest)
          : requirement.value !== undefined
            ? String(requirement.value)
            : "",
      };
    });
  }

  private async routeMatchesByType(matches: MatchResult[]): Promise<void> {
    for (const match of matches) {
      const { ucMatch, value } = match;
      if (ucMatch.type !== "specification") {
        console.warn(
          `[Route] ? Ignoring unsupported node type: ${ucMatch.type}`,
        );
        continue;
      }

      await this.handleSpecificationMatch(ucMatch.id, value, match);
    }
  }

  // ============= SPECIFICATION HANDLING =============

  private async handleSpecificationMatch(
    specId: string,
    value: unknown,
    match: MatchResult,
  ): Promise<void> {
    console.log(`[Route] ðŸŽ¯ SPECIFICATION: ${specId} = ${value}`);

    // If artifact manager available, use full Week 2 flow
    if (!this.artifactManager) {
      console.error(`[Route] âš ï¸  No artifact manager`);
      return;
    }

    try {
      const uc8Spec = ucDataLayer.getSpecification(specId);
      if (!uc8Spec) {
        console.warn(
          `[Route] âš ï¸  Specification ${specId} not found in UC8 dataset`,
        );
        return;
      }

      console.log(`[Route] âœ… Found UC8 spec: ${uc8Spec.name} (${specId})`);

      // Step 2: Add to mapped artifact
      await this.artifactManager.addSpecificationToMapped(
        uc8Spec,
        value,
        match.extractedNode.context || "",
        match.ucMatch.rationale || "",
        "llm",
      );

      // Step 3: Trigger conflict detection
      const conflictResult =
        await this.artifactManager.detectExclusionConflicts();

      // Step 4: NO auto-resolution, ALL conflicts go to agent for binary question
      if (conflictResult.hasConflict) {
        console.log(
          `[Route] ðŸš¨ ${conflictResult.conflicts.length} conflict(s) detected - BLOCKING for user resolution`,
        );
        console.log(
          `[Route] Conflict types: ${conflictResult.conflicts
            .map((c) => c.type)
            .join(", ")}`,
        );
        // Do NOT move to respec - specs stay in mapped until user resolves via agent
        // Agent will receive conflict data via getActiveConflictsForAgent() in app.tsx
      } else {
        console.log(
          `[Route] âœ… No conflicts - moving non-conflicting specs to respec`,
        );
        await this.artifactManager.moveNonConflictingToRespec();
      }
    } catch (error) {
      console.error(
        `[Route] âŒ Error handling specification ${specId}:`,
        error,
      );
    }
  }

  // ============= UTILITY METHODS =============

  private buildExtractionSummary(matches: MatchResult[]): string {
    if (matches.length === 0) {
      return "No UC matches found";
    }

    const specCount = matches.filter(
      (m) => m.ucMatch.type === "specification",
    ).length;

    return `Matched ${matches.length} nodes: ${specCount} specs`;
  }

  private calculateAverageConfidence(matches: MatchResult[]): number {
    if (matches.length === 0) return 0.5;

    const sum = matches.reduce((acc, m) => acc + m.ucMatch.confidence, 0);
    return sum / matches.length;
  }
}

// ============= FACTORY FUNCTION =============

export function createSemanticIntegrationService(
  semanticExtractor: SemanticExtractor,
  artifactManager?: ArtifactManager,
): SemanticIntegrationService {
  return new SemanticIntegrationService(semanticExtractor, artifactManager);
}
