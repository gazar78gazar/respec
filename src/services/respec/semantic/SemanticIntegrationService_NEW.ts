/**
 * SemanticIntegrationService - Integration Layer (REVISED for Sprint 2)
 *
 * Purpose: Bridge between Agent extraction and UC1 semantic matching
 * - Receives: Already-extracted requirements from Agent (AnthropicService)
 * - Does: Routes to SemanticMatchingService for UC1 matching
 * - Returns: Matched results with form updates
 *
 * This provides:
 * - Fault domain isolation (Agent ‚Üê ‚Üí Matcher)
 * - Logging at integration boundaries
 * - Error handling without breaking agent
 * - Transformation between formats
 */

import { SemanticMatchingService, ExtractedNode, MatchResult } from './SemanticMatchingService';
import { EnhancedFormUpdate, ChatResult } from '../SimplifiedRespecService';
import { CompatibilityLayer } from '../artifacts/CompatibilityLayer';
import { UC1ValidationEngine } from '../UC1ValidationEngine';
import { ArtifactManager } from '../artifacts/ArtifactManager';

// ============= INTEGRATION TYPES =============

export interface EnhancedChatResult extends ChatResult {
  matchResults?: MatchResult[];
  extractionSummary?: string;
  conflictsDetected?: any[];
  nextSuggestions?: string[];
}

export interface SemanticProcessingOptions {
  confidenceThreshold: number;
  includeDebugInfo: boolean;
}

// ============= MAIN INTEGRATION SERVICE =============

export class SemanticIntegrationService {
  private semanticMatchingService: SemanticMatchingService;
  private uc1Engine: UC1ValidationEngine;
  private artifactManager: ArtifactManager | null = null;
  private compatibilityLayer: CompatibilityLayer | null = null;
  private processingOptions: SemanticProcessingOptions;

  constructor(
    semanticMatchingService: SemanticMatchingService,
    uc1Engine: UC1ValidationEngine,
    artifactManager?: ArtifactManager,
    compatibilityLayer?: CompatibilityLayer
  ) {
    this.semanticMatchingService = semanticMatchingService;
    this.uc1Engine = uc1Engine;
    this.artifactManager = artifactManager || null;
    this.compatibilityLayer = compatibilityLayer || null;

    // Default processing options
    this.processingOptions = {
      confidenceThreshold: 0.7,
      includeDebugInfo: false
    };
  }

  // ============= MAIN PROCESSING METHOD =============

  /**
   * Process already-extracted requirements from Agent
   * @param extractedRequirements - Requirements extracted by AnthropicService
   * @param conversationalResponse - Response generated by Agent
   * @returns EnhancedChatResult with UC1 matches and form updates
   */
  async processExtractedRequirements(
    extractedRequirements: any[],
    conversationalResponse: string
  ): Promise<EnhancedChatResult> {

    try {
      console.log('[SemanticIntegration] üì® Received', extractedRequirements.length, 'extracted requirements');

      // Convert agent extractions to ExtractedNode format
      const extractedNodes = this.convertToExtractedNodes(extractedRequirements);

      if (extractedNodes.length === 0) {
        console.log('[SemanticIntegration] ‚ö†Ô∏è  No requirements to match');
        return {
          success: true,
          systemMessage: conversationalResponse,
          formUpdates: [],
          confidence: 1.0
        };
      }

      // Match to UC1
      console.log('[SemanticIntegration] üîç Sending to SemanticMatchingService...');
      const matchResults = await this.semanticMatchingService.matchExtractedNodesToUC1(extractedNodes);
      console.log('[SemanticIntegration] ‚úÖ Received', matchResults.length, 'UC1 matches');

      // Log matches for debugging
      matchResults.forEach(match => {
        console.log(`[SemanticIntegration] üìç Match:`, {
          text: match.extractedNode.text,
          uc1: `${match.uc1Match.id} (${match.uc1Match.name})`,
          type: match.uc1Match.type,
          confidence: match.uc1Match.confidence
        });
      });

      // Filter by confidence threshold
      const highConfidenceMatches = matchResults.filter(
        m => m.uc1Match.confidence >= this.processingOptions.confidenceThreshold
      );

      console.log('[SemanticIntegration] üéØ', highConfidenceMatches.length, 'matches above threshold');

      // Route matches by node type
      await this.routeMatchesByType(highConfidenceMatches);

      // Convert to form updates
      const formUpdates = this.convertMatchesToFormUpdates(highConfidenceMatches);

      console.log('[SemanticIntegration] üìù', formUpdates.length, 'form updates generated');

      // Build result
      const result: EnhancedChatResult = {
        success: true,
        systemMessage: conversationalResponse, // Use Agent's response
        formUpdates,
        confidence: this.calculateAverageConfidence(matchResults),
        matchResults: this.processingOptions.includeDebugInfo ? matchResults : undefined,
        extractionSummary: this.buildExtractionSummary(matchResults)
      };

      return result;

    } catch (error) {
      console.error('[SemanticIntegration] ‚ùå Processing failed:', error);
      throw error; // Fail fast for MVP
    }
  }

  // ============= CONVERSION METHODS =============

  private convertToExtractedNodes(requirements: any[]): ExtractedNode[] {
    return requirements.map(req => ({
      text: `${req.field}: ${req.value}`,
      category: req.section,
      value: req.value,
      context: req.originalRequest || req.value
    }));
  }

  private convertMatchesToFormUpdates(matches: MatchResult[]): EnhancedFormUpdate[] {
    const formUpdates: EnhancedFormUpdate[] = [];

    for (const match of matches) {
      // Only specifications can update form (requirements/domains cannot)
      if (match.uc1Match.type !== 'specification') {
        console.log(`[SemanticIntegration] ‚è≠Ô∏è  Skipping ${match.uc1Match.type} (not a specification)`);
        continue;
      }

      // Get form field mapping
      const fieldMapping = this.compatibilityLayer?.getFieldFromSpecId(match.uc1Match.id);

      if (!fieldMapping) {
        console.warn(`[SemanticIntegration] ‚ö†Ô∏è  No form mapping for ${match.uc1Match.id}`);
        continue;
      }

      // Get UC1 specification to retrieve proper value from options
      const uc1Spec = this.uc1Engine.getSpecification(match.uc1Match.id);

      let finalValue = match.value;
      let substitutionNote = match.uc1Match.matchType === 'semantic'
        ? `Matched semantically: ${match.uc1Match.rationale}`
        : undefined;

      if (uc1Spec) {
        // If spec has options (dropdown), select the best match
        if (uc1Spec.options && uc1Spec.options.length > 0) {
          const selectedOption = this.selectBestOption(
            match.value,
            match.extractedNode.text,
            uc1Spec.options
          );

          if (selectedOption !== match.value) {
            substitutionNote = `Selected "${selectedOption}" from available options (you requested: "${match.extractedNode.context}")`;
            console.log(`[SemanticIntegration] üîÑ Value substitution: "${match.value}" ‚Üí "${selectedOption}"`);
          }

          finalValue = selectedOption;
        } else if (!match.value && uc1Spec.default_value) {
          // Use default if no value extracted
          finalValue = uc1Spec.default_value;
          substitutionNote = `Used default value "${uc1Spec.default_value}"`;
          console.log(`[SemanticIntegration] üîÑ Using default: ${finalValue}`);
        }
      }

      // Create form update
      formUpdates.push({
        section: fieldMapping.section,
        field: fieldMapping.field,
        value: finalValue,
        confidence: match.uc1Match.confidence,
        isAssumption: match.uc1Match.confidence < 0.9,
        originalRequest: match.extractedNode.context,
        substitutionNote
      });
    }

    return formUpdates;
  }

  /**
   * Select best matching option from dropdown values
   * Uses case-insensitive partial matching and semantic similarity
   */
  private selectBestOption(
    extractedValue: any,
    extractedText: string,
    availableOptions: string[]
  ): string {
    // If extracted value is already in options, use it
    if (availableOptions.includes(extractedValue)) {
      return extractedValue;
    }

    // Try case-insensitive exact match
    const lowerValue = String(extractedValue || '').toLowerCase();
    const exactMatch = availableOptions.find(opt => opt.toLowerCase() === lowerValue);
    if (exactMatch) return exactMatch;

    // Try partial match (e.g., "fanless" matches "Fanless Operation")
    const partialMatch = availableOptions.find(opt =>
      opt.toLowerCase().includes(lowerValue) ||
      lowerValue.includes(opt.toLowerCase())
    );
    if (partialMatch) return partialMatch;

    // Try semantic matching on extracted text (e.g., "compact" ‚Üí "Compact")
    const textLower = extractedText.toLowerCase();
    const semanticMatch = availableOptions.find(opt => {
      const optLower = opt.toLowerCase();
      return textLower.includes(optLower) || optLower.includes(textLower);
    });
    if (semanticMatch) return semanticMatch;

    // Fallback to first option (with warning)
    console.warn(`[SemanticIntegration] ‚ö†Ô∏è  Could not match "${extractedValue}" to options:`, availableOptions);
    return availableOptions[0];
  }

  // ============= ROUTING BY NODE TYPE (Sprint 2 Week 2: Artifact Management) =============

  private async routeMatchesByType(matches: MatchResult[]): Promise<void> {
    for (const match of matches) {
      const { uc1Match, value } = match;

      switch (uc1Match.type) {
        case 'specification':
          await this.handleSpecificationMatch(uc1Match.id, value, match);
          break;

        case 'requirement':
          await this.handleRequirementMatch(uc1Match.id);
          break;

        case 'domain':
          await this.handleDomainMatch(uc1Match.id);
          break;

        default:
          console.warn(`[Route] ‚ùì Unknown node type: ${uc1Match.type}`);
      }
    }
  }

  // ============= SPECIFICATION HANDLING =============

  private async handleSpecificationMatch(
    specId: string,
    value: any,
    match: MatchResult
  ): Promise<void> {
    console.log(`[Route] üéØ SPECIFICATION: ${specId} = ${value}`);

    // If artifact manager available, use full Week 2 flow
    if (this.artifactManager) {
      try {
        // Step 1: Get UC1 specification
        const uc1Spec = this.uc1Engine.getSpecification(specId);
        if (!uc1Spec) {
          console.warn(`[Route] ‚ö†Ô∏è  Specification ${specId} not found in UC1 schema`);
          return;
        }

        // Step 2: Add to mapped artifact
        await this.artifactManager.addSpecificationToMapped(
          uc1Spec,
          value,
          match.extractedNode.context,
          match.uc1Match.rationale
        );

        // Step 3: Trigger conflict detection
        const conflictResult = await this.artifactManager.detectConflicts();

        // Step 4: If no conflicts, move to respec artifact
        if (!conflictResult.hasConflict) {
          console.log(`[Route] ‚úÖ No conflicts - moving non-conflicting specs to respec`);
          await this.artifactManager.moveNonConflictingToRespec();
        } else {
          console.log(`[Route] ‚ö†Ô∏è  ${conflictResult.conflicts.length} conflict(s) detected - holding in mapped`);
          // Conflicts will be handled by Sprint 3 resolution flow
        }
      } catch (error) {
        console.error(`[Route] ‚ùå Error handling specification ${specId}:`, error);
        // Fall through to legacy behavior
      }
    } else {
      // Legacy path: no artifact manager (shouldn't happen in Sprint 2 Week 2)
      console.log(`[Route] ‚ö†Ô∏è  No artifact manager - using legacy path`);
    }
  }

  // ============= REQUIREMENT HANDLING =============

  private async handleRequirementMatch(reqId: string): Promise<void> {
    console.log(`[Route] üìã REQUIREMENT: ${reqId}`);

    if (this.artifactManager) {
      try {
        // Get all child specifications for this requirement
        const childSpecs = this.uc1Engine.getSpecificationsByRequirement(reqId);

        if (childSpecs.length === 0) {
          console.warn(`[Route] ‚ö†Ô∏è  No specifications found for requirement ${reqId}`);
          return;
        }

        console.log(`[Route] üìã Found ${childSpecs.length} specifications for requirement ${reqId}`);

        // Add all child specifications to mapped artifact
        for (const spec of childSpecs) {
          await this.artifactManager.addSpecificationToMapped(
            spec,
            spec.default_value || null,
            `From requirement ${reqId}`,
            `Auto-added as part of requirement ${reqId}`
          );
        }

        // Trigger conflict detection
        const conflictResult = await this.artifactManager.detectConflicts();

        if (!conflictResult.hasConflict) {
          console.log(`[Route] ‚úÖ No conflicts - moving requirement + ${childSpecs.length} children to respec`);
          await this.artifactManager.moveNonConflictingToRespec();
        } else {
          console.log(`[Route] ‚ö†Ô∏è  Conflicts detected - holding requirement in mapped`);
        }
      } catch (error) {
        console.error(`[Route] ‚ùå Error handling requirement ${reqId}:`, error);
      }
    }
  }

  // ============= DOMAIN HANDLING =============

  private async handleDomainMatch(domainId: string): Promise<void> {
    console.log(`[Route] üè¢ DOMAIN: ${domainId}`);

    if (this.artifactManager) {
      try {
        // Get domain and all child requirements + specifications
        const domain = this.uc1Engine.getDomains().find(d => d.id === domainId);
        if (!domain) {
          console.warn(`[Route] ‚ö†Ô∏è  Domain ${domainId} not found in UC1 schema`);
          return;
        }

        const childRequirements = this.uc1Engine.getRequirementsByDomain(domainId);

        // Add all child specifications from all requirements
        for (const req of childRequirements) {
          const childSpecs = this.uc1Engine.getSpecificationsByRequirement(req.id);

          for (const spec of childSpecs) {
            await this.artifactManager.addSpecificationToMapped(
              spec,
              spec.default_value || null,
              `From domain ${domainId}`,
              `Auto-added as part of domain ${domain.name}`
            );
          }
        }

        // Trigger conflict detection
        const conflictResult = await this.artifactManager.detectConflicts();

        if (!conflictResult.hasConflict) {
          console.log(`[Route] ‚úÖ No conflicts - moving domain + descendants to respec`);
          await this.artifactManager.moveNonConflictingToRespec();
        } else {
          console.log(`[Route] ‚ö†Ô∏è  Conflicts detected - holding domain in mapped`);
        }
      } catch (error) {
        console.error(`[Route] ‚ùå Error handling domain ${domainId}:`, error);
      }
    }
  }

  // ============= UTILITY METHODS =============

  private buildExtractionSummary(matches: MatchResult[]): string {
    if (matches.length === 0) {
      return 'No UC1 matches found';
    }

    const byType = {
      specification: matches.filter(m => m.uc1Match.type === 'specification').length,
      requirement: matches.filter(m => m.uc1Match.type === 'requirement').length,
      domain: matches.filter(m => m.uc1Match.type === 'domain').length
    };

    return `Matched ${matches.length} nodes: ${byType.specification} specs, ${byType.requirement} reqs, ${byType.domain} domains`;
  }

  private calculateAverageConfidence(matches: MatchResult[]): number {
    if (matches.length === 0) return 0.5;

    const sum = matches.reduce((acc, m) => acc + m.uc1Match.confidence, 0);
    return sum / matches.length;
  }
}

// ============= FACTORY FUNCTION =============

export function createSemanticIntegrationService(
  semanticMatchingService: SemanticMatchingService,
  uc1Engine: UC1ValidationEngine,
  artifactManager?: ArtifactManager,
  compatibilityLayer?: CompatibilityLayer
): SemanticIntegrationService {
  return new SemanticIntegrationService(semanticMatchingService, uc1Engine, artifactManager, compatibilityLayer);
}
