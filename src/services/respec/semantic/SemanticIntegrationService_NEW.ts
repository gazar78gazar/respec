/**
 * SemanticIntegrationService - Integration Layer (REVISED for Sprint 2)
 *
 * Purpose: Bridge between Agent extraction and UC1 semantic matching
 * - Receives: Already-extracted requirements from Agent (AnthropicService)
 * - Does: Routes to SemanticMatchingService for UC1 matching
 * - Returns: Matched results with form updates
 *
 * This provides:
 * - Fault isolation (Agent ‚Üê ‚Üí Matcher)
 * - Logging at integration boundaries
 * - Error handling without breaking agent
 * - Transformation between formats
 */

import { SemanticMatchingService, ExtractedNode, MatchResult } from './SemanticMatchingService';
import { EnhancedFormUpdate, ChatResult } from '../SimplifiedRespecService';
import { UC1ValidationEngine, UC1Specification } from '../UC1ValidationEngine';
import { ArtifactManager } from '../artifacts/ArtifactManager';
import { ucDataLayer } from '../../data/UCDataLayer';

// ============= INTEGRATION TYPES =============

export interface EnhancedChatResult extends ChatResult {
  matchResults?: MatchResult[];
  extractionSummary?: string;
  conflictsDetected?: any[];
  nextSuggestions?: string[];
}

export interface SemanticProcessingOptions {
  confidenceThreshold: number;
  includeDebugInfo: boolean;
}

// ============= MAIN INTEGRATION SERVICE =============

export class SemanticIntegrationService {
  private semanticMatchingService: SemanticMatchingService;
  private uc1Engine: UC1ValidationEngine;
  private artifactManager: ArtifactManager | null = null;
  private processingOptions: SemanticProcessingOptions;

  constructor(
    semanticMatchingService: SemanticMatchingService,
    uc1Engine: UC1ValidationEngine,
    artifactManager?: ArtifactManager
  ) {
    this.semanticMatchingService = semanticMatchingService;
    this.uc1Engine = uc1Engine;
    this.artifactManager = artifactManager || null;

    // Default processing options
    this.processingOptions = {
      confidenceThreshold: 0.7,
      includeDebugInfo: false
    };
  }

  // ============= MAIN PROCESSING METHOD =============

  /**
   * Process already-extracted requirements from Agent
   * @param extractedRequirements - Requirements extracted by AnthropicService
   * @param conversationalResponse - Response generated by Agent
   * @returns EnhancedChatResult with UC1 matches and form updates
   */
  async processExtractedRequirements(
    extractedRequirements: any[],
    conversationalResponse: string
  ): Promise<EnhancedChatResult> {

    try {
      console.log('[SemanticIntegration] üì® Received', extractedRequirements.length, 'extracted requirements');

      // Convert agent extractions to ExtractedNode format
      const extractedNodes = this.convertToExtractedNodes(extractedRequirements);

      if (extractedNodes.length === 0) {
        console.log('[SemanticIntegration] ‚ö†Ô∏è  No requirements to match');
        return {
          success: true,
          systemMessage: conversationalResponse,
          formUpdates: [],
          confidence: 1.0
        };
      }

      // Match to UC1
      console.log('[SemanticIntegration] üîç Sending to SemanticMatchingService...');
      const matchResults = await this.semanticMatchingService.matchExtractedNodesToUC1(extractedNodes);
      console.log('[SemanticIntegration] ‚úÖ Received', matchResults.length, 'UC1 matches');

      // Log matches for debugging
      matchResults.forEach(match => {
        console.log(`[SemanticIntegration] üìç Match:`, {
          text: match.extractedNode.text,
          uc1: `${match.uc1Match.id} (${match.uc1Match.name})`,
          type: match.uc1Match.type,
          confidence: match.uc1Match.confidence
        });
      });

      // Filter by confidence threshold
      const highConfidenceMatches = matchResults.filter(
        m => m.uc1Match.confidence >= this.processingOptions.confidenceThreshold
      );

      console.log('[SemanticIntegration] üéØ', highConfidenceMatches.length, 'matches above threshold');

      // Route matches by node type (this adds specs to artifacts, including auto-fulfilled dependencies)
      await this.routeMatchesByType(highConfidenceMatches);

      // Generate form updates from respec artifact (includes auto-added dependencies)
      const formUpdates = this.generateFormUpdatesFromRespec();

      console.log('[SemanticIntegration] üìù', formUpdates.length, 'form updates generated (includes dependencies)');

      // Build result
      const result: EnhancedChatResult = {
        success: true,
        systemMessage: conversationalResponse, // Use Agent's response
        formUpdates,
        confidence: this.calculateAverageConfidence(matchResults),
        matchResults: this.processingOptions.includeDebugInfo ? matchResults : undefined,
        extractionSummary: this.buildExtractionSummary(matchResults)
      };

      return result;

    } catch (error) {
      console.error('[SemanticIntegration] ‚ùå Processing failed:', error);
      throw error; // Fail fast for MVP
    }
  }

  // ============= CONVERSION METHODS =============

  private convertToExtractedNodes(requirements: any[]): ExtractedNode[] {
    return requirements.map(req => ({
      text: `${req.field}: ${req.value}`,
      category: req.section,
      value: req.value,
      context: req.originalRequest || req.value
    }));
  }

  // Legacy method - kept for reference, now using generateFormUpdatesFromRespec()
  private _convertMatchesToFormUpdates(matches: MatchResult[]): EnhancedFormUpdate[] {
    const formUpdates: EnhancedFormUpdate[] = [];

    for (const match of matches) {
      // Only specifications can update form (requirements/scenarios cannot)
      if (match.uc1Match.type !== 'specification') {
        console.log(`[SemanticIntegration] ‚è≠Ô∏è  Skipping ${match.uc1Match.type} (not a specification)`);
        continue;
      }

      // Get form field mapping from UC8 specification (UC8 specs have form_mapping built-in)
      const uc8Spec = ucDataLayer.getSpecification(match.uc1Match.id);

      if (!uc8Spec?.form_mapping) {
        console.warn(`[SemanticIntegration] ‚ö†Ô∏è  No form mapping for ${match.uc1Match.id}`);
        continue;
      }

      const fieldMapping = {
        section: uc8Spec.form_mapping.section,
        field: uc8Spec.form_mapping.field_name,
        category: uc8Spec.form_mapping.category || uc8Spec.form_mapping.section
      };

      // Get UC1 specification to retrieve proper value from options
      const uc1Spec = this.uc1Engine.getSpecification(match.uc1Match.id);

      let finalValue = match.value;
      let substitutionNote = match.uc1Match.matchType === 'semantic'
        ? `Matched semantically: ${match.uc1Match.rationale}`
        : undefined;

      if (uc1Spec) {
        // If spec has options (dropdown), select the best match
        if (uc1Spec.options && uc1Spec.options.length > 0) {
          const selectedOption = this.selectBestOption(
            match.value,
            match.extractedNode.text,
            uc1Spec.options
          );

          if (selectedOption !== match.value) {
            substitutionNote = `Selected "${selectedOption}" from available options (you requested: "${match.extractedNode.context}")`;
            console.log(`[SemanticIntegration] üîÑ Value substitution: "${match.value}" ‚Üí "${selectedOption}"`);
          }

          finalValue = selectedOption;
        } else if (!match.value && uc1Spec.default_value) {
          // Use default if no value extracted
          finalValue = uc1Spec.default_value;
          substitutionNote = `Used default value "${uc1Spec.default_value}"`;
          console.log(`[SemanticIntegration] üîÑ Using default: ${finalValue}`);
        }
      }

      // Create form update
      formUpdates.push({
        section: fieldMapping.section,
        field: fieldMapping.field,
        value: finalValue,
        confidence: match.uc1Match.confidence,
        isAssumption: match.uc1Match.confidence < 0.9,
        originalRequest: match.extractedNode.context,
        substitutionNote
      });
    }

    return formUpdates;
  }

  /**
   * Generate form updates from respec artifact
   * This includes auto-added dependency specs that weren't in the original matches
   */
  private generateFormUpdatesFromRespec(): EnhancedFormUpdate[] {
    const formUpdates: EnhancedFormUpdate[] = [];

    if (!this.artifactManager) {
      console.warn('[SemanticIntegration] No artifact manager - cannot generate form updates');
      return formUpdates;
    }

    // Get the respec artifact which contains all approved specs (including dependencies)
    const respecArtifact = this.artifactManager.getRespecArtifact();

    // Iterate through all specifications in respec artifact
    Object.values(respecArtifact.scenarios).forEach(scenario => {
      Object.values(scenario.requirements).forEach(requirement => {
        Object.values(requirement.specifications).forEach(spec => {
          // Get form field mapping from UC8 specification (UC8 specs have form_mapping built-in)
          const uc8SpecForMapping = ucDataLayer.getSpecification(spec.id);

          if (!uc8SpecForMapping?.form_mapping) {
            console.log(`[SemanticIntegration] ‚è≠Ô∏è  No form mapping for ${spec.id} (may be comment type)`);
            return;
          }

          const fieldMapping = {
            section: uc8SpecForMapping.form_mapping.section,
            field: uc8SpecForMapping.form_mapping.field_name,
            category: uc8SpecForMapping.form_mapping.category || uc8SpecForMapping.form_mapping.section
          };

          console.log(`[SemanticIntegration] üìã Generating form update for ${spec.id} = ${spec.value}`);

          // Create form update
          formUpdates.push({
            section: fieldMapping.section,
            field: fieldMapping.field,
            value: spec.value,
            confidence: spec.confidence || 1.0,
            isAssumption: spec.source === 'llm' && (spec.confidence || 1.0) < 0.9,
            originalRequest: spec.originalRequest,
            substitutionNote: spec.substitutionNote
          });
        });
      });
    });

    return formUpdates;
  }

  /**
   * Select best matching option from dropdown values
   * Uses case-insensitive partial matching and semantic similarity
   */
  private selectBestOption(
    extractedValue: any,
    extractedText: string,
    availableOptions: string[]
  ): string {
    // If extracted value is already in options, use it
    if (availableOptions.includes(extractedValue)) {
      return extractedValue;
    }

    // Try case-insensitive exact match
    const lowerValue = String(extractedValue || '').toLowerCase();
    const exactMatch = availableOptions.find(opt => opt.toLowerCase() === lowerValue);
    if (exactMatch) return exactMatch;

    // Try partial match (e.g., "fanless" matches "Fanless Operation")
    const partialMatch = availableOptions.find(opt =>
      opt.toLowerCase().includes(lowerValue) ||
      lowerValue.includes(opt.toLowerCase())
    );
    if (partialMatch) return partialMatch;

    // Try semantic matching on extracted text (e.g., "compact" ‚Üí "Compact")
    const textLower = extractedText.toLowerCase();
    const semanticMatch = availableOptions.find(opt => {
      const optLower = opt.toLowerCase();
      return textLower.includes(optLower) || optLower.includes(textLower);
    });
    if (semanticMatch) return semanticMatch;

    // Fallback to first option (with warning)
    console.warn(`[SemanticIntegration] ‚ö†Ô∏è  Could not match "${extractedValue}" to options:`, availableOptions);
    return availableOptions[0];
  }

  // ============= ROUTING BY NODE TYPE (Sprint 2 Week 2: Artifact Management) =============

  private async routeMatchesByType(matches: MatchResult[]): Promise<void> {
    for (const match of matches) {
      const { uc1Match, value } = match;

      switch (uc1Match.type) {
        case 'specification':
          await this.handleSpecificationMatch(uc1Match.id, value, match);
          break;

        case 'requirement':
          await this.handleRequirementMatch(uc1Match.id);
          break;

        case 'scenario':
          await this.handleScenarioMatch(uc1Match.id);
          break;

        default:
          console.warn(`[Route] ‚ùì Unknown node type: ${uc1Match.type}`);
      }
    }
  }

  // ============= SPECIFICATION HANDLING =============

  private async handleSpecificationMatch(
    specId: string,
    value: any,
    match: MatchResult
  ): Promise<void> {
    console.log(`[Route] üéØ SPECIFICATION: ${specId} = ${value}`);

    // If artifact manager available, use full Week 2 flow
    if (this.artifactManager) {
      try {
        // SPRINT 3 FIX: Get specification from UCDataLayer (P## IDs) instead of UC1Engine (spc### IDs)
        const uc8Spec = ucDataLayer.getSpecification(specId);
        if (!uc8Spec) {
          console.warn(`[Route] ‚ö†Ô∏è  Specification ${specId} not found in UC8 dataset`);
          return;
        }

        // UC8 spec needs to be converted to UC1 format for compatibility with ArtifactManager
        // TODO: Refactor ArtifactManager to use UC8 types directly
        const uc1Spec: UC1Specification = {
          id: uc8Spec.id,
          type: 'specification',
          name: uc8Spec.name,
          form_mapping: uc8Spec.form_mapping,
          category: uc8Spec.form_mapping?.category || uc8Spec.form_mapping?.section || 'unknown',
          parent: uc8Spec.parent_requirements || [],
          options: uc8Spec.options,
          description: uc8Spec.description,
          dependencies: [] // UC8 uses 'requires' field differently
        };

        console.log(`[Route] ‚úÖ Found UC8 spec: ${uc8Spec.name} (${specId})`);

        // Step 2: Add to mapped artifact
        await this.artifactManager.addSpecificationToMapped(
          uc1Spec,
          value,
          match.extractedNode.context,
          match.uc1Match.rationale
        );

        // Step 3: Trigger conflict detection
        const conflictResult = await this.artifactManager.detectConflicts();

        // Step 4: Sprint 3 - NO auto-resolution, ALL conflicts go to agent for binary question
        if (conflictResult.hasConflict) {
          console.log(`[Route] üö® ${conflictResult.conflicts.length} conflict(s) detected - BLOCKING for user resolution`);
          console.log(`[Route] Conflict types: ${conflictResult.conflicts.map(c => c.type).join(', ')}`);
          // Do NOT move to respec - specs stay in mapped until user resolves via agent
          // Agent will receive conflict data via getActiveConflictsForAgent() in app.tsx
        } else {
          console.log(`[Route] ‚úÖ No conflicts - moving non-conflicting specs to respec`);
          await this.artifactManager.moveNonConflictingToRespec();
        }
      } catch (error) {
        console.error(`[Route] ‚ùå Error handling specification ${specId}:`, error);
        // Fall through to legacy behavior
      }
    } else {
      // Legacy path: no artifact manager (shouldn't happen in Sprint 2 Week 2)
      console.log(`[Route] ‚ö†Ô∏è  No artifact manager - using legacy path`);
    }
  }

  // ============= REQUIREMENT HANDLING =============

  private async handleRequirementMatch(reqId: string): Promise<void> {
    console.log(`[Route] üìã REQUIREMENT: ${reqId}`);

    if (this.artifactManager) {
      try {
        // Get all child specifications for this requirement
        const childSpecs = this.uc1Engine.getSpecificationsByRequirement(reqId);

        if (childSpecs.length === 0) {
          console.warn(`[Route] ‚ö†Ô∏è  No specifications found for requirement ${reqId}`);
          return;
        }

        console.log(`[Route] üìã Found ${childSpecs.length} specifications for requirement ${reqId}`);

        // Add all child specifications to mapped artifact
        // Sprint 3 Week 1: Check for existing user-selected values before adding
        for (const spec of childSpecs) {
          // Check if spec already exists with user-selected value
          const existingInMapped = this.artifactManager.findSpecificationInArtifact('mapped', spec.id);
          const existingInRespec = this.artifactManager.findSpecificationInArtifact('respec', spec.id);

          if (existingInMapped) {
            // Check source - preserve user selections
            if (existingInMapped.source === 'user' || existingInMapped.source === 'direct_extraction') {
              console.log(
                `[Route] ‚ö†Ô∏è  Skipping ${spec.id} - user-selected value already exists in mapped ` +
                `(value: "${existingInMapped.value}")`
              );
              continue; // Don't overwrite user selection
            } else {
              console.log(
                `[Route] Spec ${spec.id} exists in mapped with system value, will be updated`
              );
            }
          }

          if (existingInRespec) {
            // Spec already in respec - cross-artifact conflict will be detected
            console.log(
              `[Route] ‚ö†Ô∏è  Spec ${spec.id} exists in respec - cross-artifact conflict will be detected`
            );
            // Continue adding to mapped, conflict detection will handle it
          }

          await this.artifactManager.addSpecificationToMapped(
            spec,
            spec.default_value || null,
            `From requirement ${reqId}`,
            `Auto-added as part of requirement ${reqId}`
          );
        }

        // Trigger conflict detection
        const conflictResult = await this.artifactManager.detectConflicts();

        if (!conflictResult.hasConflict) {
          console.log(`[Route] ‚úÖ No conflicts - moving requirement + ${childSpecs.length} children to respec`);
          await this.artifactManager.moveNonConflictingToRespec();
        } else {
          console.log(`[Route] ‚ö†Ô∏è  Conflicts detected - holding requirement in mapped`);
        }
      } catch (error) {
        console.error(`[Route] ‚ùå Error handling requirement ${reqId}:`, error);
      }
    }
  }

  // ============= SCENARIO HANDLING =============

  private async handleScenarioMatch(scenarioId: string): Promise<void> {
    console.log(`[Route] üè¢ SCENARIO: ${scenarioId}`);

    if (this.artifactManager) {
      try {
        // Get scenario and all child requirements + specifications
        const scenario = this.uc8Engine.getScenarios().find(d => d.id === scenarioId);
        if (!scenario) {
          console.warn(`[Route] ‚ö†Ô∏è  Scenario ${scenarioId} not found in UC8 schema`);
          return;
        }

        const childRequirements = this.uc8Engine.getRequirementsByScenario(scenarioId);

        // Add all child specifications from all requirements
        // Sprint 3 Week 1: Check for existing user-selected values before adding
        for (const req of childRequirements) {
          const childSpecs = this.uc1Engine.getSpecificationsByRequirement(req.id);

          for (const spec of childSpecs) {
            // Check if spec already exists with user-selected value
            const existingInMapped = this.artifactManager.findSpecificationInArtifact('mapped', spec.id);
            const existingInRespec = this.artifactManager.findSpecificationInArtifact('respec', spec.id);

            if (existingInMapped) {
              if (existingInMapped.source === 'user' || existingInMapped.source === 'direct_extraction') {
                console.log(
                  `[Route] ‚ö†Ô∏è  Skipping ${spec.id} - user-selected value already exists in mapped`
                );
                continue;
              }
            }

            if (existingInRespec) {
              console.log(
                `[Route] ‚ö†Ô∏è  Spec ${spec.id} exists in respec - cross-artifact conflict will be detected`
              );
            }

            await this.artifactManager.addSpecificationToMapped(
              spec,
              spec.default_value || null,
              `From scenario ${scenarioId}`,
              `Auto-added as part of scenario ${scenario.name}`
            );
          }
        }

        // Trigger conflict detection
        const conflictResult = await this.artifactManager.detectConflicts();

        if (!conflictResult.hasConflict) {
          console.log(`[Route] ‚úÖ No conflicts - moving scenario + descendants to respec`);
          await this.artifactManager.moveNonConflictingToRespec();
        } else {
          console.log(`[Route] ‚ö†Ô∏è  Conflicts detected - holding scenario in mapped`);
        }
      } catch (error) {
        console.error(`[Route] ‚ùå Error handling scenario ${scenarioId}:`, error);
      }
    }
  }

  // ============= UTILITY METHODS =============

  private buildExtractionSummary(matches: MatchResult[]): string {
    if (matches.length === 0) {
      return 'No UC1 matches found';
    }

    const byType = {
      specification: matches.filter(m => m.uc1Match.type === 'specification').length,
      requirement: matches.filter(m => m.uc1Match.type === 'requirement').length,
      scenario: matches.filter(m => m.uc1Match.type === 'scenario').length
    };

    return `Matched ${matches.length} nodes: ${byType.specification} specs, ${byType.requirement} reqs, ${byType.scenario} scenarios`;
  }

  private calculateAverageConfidence(matches: MatchResult[]): number {
    if (matches.length === 0) return 0.5;

    const sum = matches.reduce((acc, m) => acc + m.uc1Match.confidence, 0);
    return sum / matches.length;
  }
}

// ============= FACTORY FUNCTION =============

export function createSemanticIntegrationService(
  semanticMatchingService: SemanticMatchingService,
  uc1Engine: UC1ValidationEngine,
  artifactManager?: ArtifactManager
): SemanticIntegrationService {
  return new SemanticIntegrationService(semanticMatchingService, uc1Engine, artifactManager);
}
